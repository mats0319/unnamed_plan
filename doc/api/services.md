# 服务的API

为了避免服务之间出现循环依赖，定义服务之间的关系，先是简单分为**基础服务**与**高级服务**两个等级。  
其中**高级服务**可以依赖**基础服务**，反之，不行；如果有业务要求基础服务依赖高级服务，优先考虑调整实现方案

## 用户系统（基础服务）

### 密码

系统中全部密码均使用hash（`sha256`）、不使用明文  
前端：用户输入明文密码，确认后（例如点击登录按钮），程序执行hash，清空输入框  
后端：从前端接收到hash后的密码，与该用户的salt再次执行hash，保存到数据库（创建）或与数据库记录对比（验证）  
数据库：密码字段实际保存的值为`sha256(sha256('明文')+'salt')`

这样一来，只有前端发起的请求被拦截并从中解析出hash后的密码，才会导致密码泄露  
即使数据库字段被获取，因为hash不可逆，理论上无法反推出前端传过来的hash后的密码，所以无法正确执行我们的登录函数

### 为什么一些功能需要输入密码

一个重要的考量是：当恶意用户不通过界面、直接构造http请求发送到网关时，程序能否做出反应  
以**创建新用户**为例，接口需要的业务参数包含`操作员ID、新用户的昵称、密码和权限等级`  
因为用户ID并非私密数据，所以存在以下可能：恶意用户使用其他人的ID注册新用户，这不是我们想要的设计  
所以我们为接口新增`操作员密码`字段

## 云文件系统（高级服务）

### 在线预览

暂时使用浏览器默认解析方式，前端限制只接收pdf类型的文件，文件大小是否要限制、限制多少**待定**

与nginx配合，前端根据url直接定位到服务器文件：

1. 后端返回的`fileURL`举例：`user_id/file_id.pdf`，
2. 前端拼上**源**和**云文件标识**：`https://mats9693.cn/cloud-file/user_id/file_id.pdf`
3. nginx识别**云文件标识**：
   ```text 
   location /cloud-file/ {
       alias /home/xxx/cloud_file/;
   }
   ```

#### 问题

1. 若已知用户id与文件id，则可以绕过系统权限验证，任意访问服务器文件
2. 结合上一条，**删除文件**功能失去实际意义
