# 设计

> 随着文档越写越多，新的功能设计往往需要往下翻若干行才能找到，故重新分类本文档：
> 1. 正在开发的功能（指导代码编写）
> 2. 草稿（关于开发笔记中**计划开发内容**模块的思考，使用`draft`标识）
> 3. 已实现的功能（归档）

## 性能监控(draft)

pprof

## 调用链追踪(draft)

日志收集，一个请求在各环节拥有同一个请求ID

## 熔断、限流、降级(draft)

熔断、降级拟合并到服务注册中心，限流拟合并到API网关

## API 网关

> 只处理http post请求，忽略其他类型的请求（忽略：直接返回成功）

网关层的主要作用是隐藏业务服务，由网关层接收全部外部访问，然后分发给各业务服务，以实现**业务服务不对外暴露**的目的

网关层还可以引入一些公共处理，例如限流、降级等功能，以及一些公共处理，例如下面提到的多登问题

### http请求响应过程

> 加载插件

1. 判断请求方法，忽略全部非`http post`方法的请求
2. 判断**请求来源**，若请求来源**无效**（未注册），则拒绝该请求
    1. 请求来源：http请求头`Unnamed-Plan-Source`字段的值
    2. 无效：启动时注册有效的来源列表，不存在于列表中的请求来源视为无效
3. 插件钩子函数：`before invoke`
4. 执行对应请求的处理函数
    1. 所有处理函数在程序启动时注册，此处根据URI获取
5. 插件钩子函数：`after invoke`
    1. 处理函数执行出错时，不执行`after invoke`函数

### http res

```go 
type ResponseData struct {
	HasError bool   `json:"hasError"`
	Data     string `json:"data"`
}
```

```hasError```表示http请求是否正确执行并按照预期返回：

1. 请求正常执行：```data```是```json string```
2. 请求执行失败：```data```是```string```类型的错误信息

### 多处登录限制 multi-login limit

#### 目的

限制同一用户同时登录多个终端的情况

#### 策略

1. 同一用户，在同一个**限制登录**的来源上，**最多**只能登录一次
2. 当一名用户尝试在同一个来源的**不同终端**上登录时，先登录的终端将被收回登录权限
    1. 不同终端：例如两个浏览器标签页

#### 设计

> 本节默认请求来源有效

1. 前端登录，获得`token`，保存到`session storage`
2. 前端其他请求将携带`token`，后端校验，校验通过则继续执行请求，满足以下条件的，视为验证通过：
    1. 后端能够从请求中解析出符合格式的`user id`与`token`
    2. `user id`与`token`是匹配的
    3. 该用户在该来源的**上一次请求时间**距**此刻**不超过一定值（可配置）
3. 前端的每一个登录请求都会生成新的`token`，后端仅记录最后一个
    1. 如此，新的登录请求成功时，旧的登录失效（旧`token`验证不通过）

#### 问题

1. 考虑引入缓存层保存用户登录信息
2. 后端识别**请求头**中的关键参数，然后把关键参数写在**请求体**里返回，  
   这种做法能够最大程度兼容```go http server```和```vue axios interceptor```的原生写法  
   简单来说就是容易实现，后续考虑统一
    1. 考虑使用服务端设置cookie的方式，涉及跨域问题

### 使用ip可能带来的共用session storage问题

> 强调：使用不同的域名（源）不会存在该问题

没有买域名，对于前台界面和后台界面的路径，参考nginx配置：（ip仅供示意）

1. public：https://117.50.177.201
2. admin ：https://117.50.177.201/admin

这就导致两个网站会共用session storage，因为我将登录信息保存在vuex、使用session storage做的vuex防刷新，  
以至于当我登录了前台界面之后，在当前浏览器标签页，通过修改url的方式访问后台界面，后台界面能够读到前台界面的vuex

又因为我没有为两个网站做代码区分，即vuex的`key`都叫`vuex`、**是否登录**字段都叫`isLogin`，所以仅从界面来看，我做到了特殊情况下的单点登录...

对此，我的解决办法是，不同的网站，vuex写session storage时，使用不同的key，以避免与其他网站的session storage混用

效果：（访问其他网站，默认在同一个浏览器标签页内）

1. 访问前台界面，登录，访问后台界面：未登录
2. 访问前台界面，登录，访问后台界面，访问前台界面：登录
3. 访问前台界面，登录，访问后台界面，登录，访问前台界面：登录

## 业务服务测试

为业务服务编写测试，可以在改动后，快速测试相关内容正确性

### 设计

构造需要测试的服务实例，使用真实数据库连接（尽量不要直接使用正式数据库，哪怕我们在表名上做了区分），mock其他服务

1. 准备阶段：
    1. 创建测试用数据库表
        1. 测试表表名由**正式表名+时间戳**构成
    2. 准备测试数据，包含数据库记录与请求参数
    3. 构造服务实例
    4. mock其他服务
2. 测试服务功能（以下步骤对应一个功能）：
    1. 构造请求参数
        1. 一些非常规的请求参数，例如上传文件时的文件原文，通过真实请求获得，即真实上传一个文件，然后拿到它的内容
    2. 调用请求方法
    3. 检查执行结果
        1. 读请求只需要验证请求方法返回值
        2. 写请求需要验证数据库记录，可能需要新的数据库查询语句，拟单独写在测试代码里
3. 测试结束后：
    1. 若测试全部通过，则删除测试用数据库表

### 问题

1. 测试的配置怎么办，在实装配置中心后，其他服务通过配置中心获取配置，配置的改变很难实时反馈到测试配置上
2. 注意：如果想要更换测试代码使用的DBMS，则需要额外编写相应DBMS的测试用sql

## 核心模块(core)

核心模块集中、统一管理微服务架构中，各个业务服务的实例，当前版本包含以下内容：

1. 配置中心：管理配置
2. 服务注册中心：管理每个业务服务实例的状态，以及请求分发

### 配置中心(config center, cc)

#### 功能

基础功能：

1. cc可以从数据库获取项目的全部配置
2. 所有服务都可以从cc获取自身的配置

高级功能：

1. 相同服务，支持不同等级(level)的配置，例如开发、生产等

#### 设计

配置结构：

1. 服务配置：一个服务的完整配置，由**配置等级**和**一组配置项**组成，举个例子：**用户服务的配置**
2. 配置项：一个模块的配置，由**配置项标识**和**一组键值对**组成，举个例子：**数据库配置项**
    1. 配置项标识：包含配置项ID、配置项名称
    2. 配置项的键值对：配置值，例如数据库配置项的`"DBMS": "postgresql"`就是一个键值对
3. 配置项可以复用，即不同服务或不同等级的相同服务，可以包含同一个配置项

cc在启动时加载全部配置，并计算出支持哪些服务的哪些配置等级，当前版本支持**默认**、**开发**、**生产**、**测试**配置等级  
其他服务携带**服务ID**、**配置等级**访问cc，如果cc支持该服务，但不支持该配置等级，则返回**默认**等级的配置

#### 问题

1. 当前通过一个**服务公共配置文件**提供cc的地址，其实可以省略这个配置文件，在**服务注册中心-嵌入模块**
   (Registration Center Embedded, RCE)中，记录cc的域名，然后通过部署手段将域名与cc联系起来（关键词：域名解析、反向代理）

#### 计划开发

1. 配置中心管理界面：为了方便修改配置
2. 配置更新同步：配置有更新，如何同步到目标服务呢？
3. 配置导出到文件：为了方便管理业务服务测试配置
4. 配置版本管理：拟将配置版本加入管理，例如**用户服务1.0版本配置**、**用户服务2.0版本配置**

### 服务注册中心(registration center, rc)

#### 功能

1. 业务服务向rc注册
2. 其他服务从rc获取指定业务服务可用实例地址列表
3. 维护实例状态（是否可用，rcc/rce）
4. 其他服务调用业务服务

#### 设计

rc包括**核心模块**和**嵌入模块**

1. 核心模块(registration center core, RCC)：服务端模块，负责响应业务服务注册、对其他服务提供服务实例查询、维护实例状态
2. 嵌入模块(registration center embedded, RCE)：嵌入到其他服务中，负责向rcc注册、调用其他业务服务
    1. 其他服务：业务服务（用到注册功能，可能用到调用功能）和需要调用业务服务的服务（用到调用功能）

在代码中，我们使用`rce`表示**服务注册中心-嵌入模块**，直接使用`rc`表示**服务注册中心-核心模块**

rcc启动，开始维护实例状态  
当有业务服务启动时，其内嵌的rce模块向rcc模块注册该服务  
当一个服务需要调用某个业务服务时，先查看自身内嵌的rce模块是否持有目标服务的实例地址，如果没有，则从rcc模块获取；如果有，选择一个地址发起调用

以下过程中，可能出现实例不可用的情况（grpc带给go的error不空），当前版本的处理规则是：直接删除不可用实例

1. rcc模块维护实例状态
2. rce模块调用业务服务

#### 问题

1. rcc重启可用：现在的rcc重启，已经注册的实例信息将被清空。考虑后期引入redis后，将实例的地址列表存放到redis

#### 计划开发

1. rce，选择实例地址的方式，考虑升级为**根据响应时间计算权重**
2. rce，维护持有的业务服务实例地址列表的方式，考虑升级为**出现网络错误时，将该实例降级，如果所有地址都降级了，则重新向核心模块请求**
3. rce，拟于rpc请求因网络原因失败时，增加**切换地址**、**重试**功能
4. rcc，维护业务服务实例地址列表的规则，考虑升级为**出现网络错误时，将该实例降级，收到rce请求时，返回正常等级实例，如果没有，则返回低级实例**
5. rcc，获取到的目标服务地址，如果与当前服务处于同一局域网内，则使用内网ip访问（没想好怎么判断内网，ip前16个bits吗）

### 说明

1. 为什么把cc和rc合并成一个服务？
    1. 因为它们都是**统一管理**的一部分，分别管理配置和示例状态、请求转发
    2. 通过画流程图可以发现，这两各模块的
