# 设计

> 随着文档越写越多，新的功能设计往往需要往下翻若干行才能找到，故重新分类本文档：
> 1. 正在开发的功能（指导代码编写）
> 2. 草稿（关于开发笔记中**计划开发内容**模块的思考，使用`draft`标识）
> 3. 已实现的功能（归档）

## 正在开发：配置中心

使用统一的配置中心管理后端服务的配置，减少修改配置的工作量

设计：

1. [x] 配置中心通过数据库获取当前配置，计算支持的服务与配置等级(level)
2. [x] 业务服务携带服务ID与配置等级，前往配置中心获取服务，获取失败时，重试几次
3. 配置中心带有管理界面，可以修改配置、输出配置（主要用于测试配置）
    1. 前端使用单独的界面，直连配置中心，暂时由配置中心内置登录用户
    2. 前端自动获取数据库中的配置格式，单独提取全部配置项的ID，用于修改服务配置-配置项ID列表
    3. 一旦修改了配置，无论哪里有改动，暂定重新计算整个**支持的服务配置**
    4. 计划开发自动推送配置功能（或许要结合服务注册中心实现）
    5. 可以将支持的服务配置写成文件（主要用于测试配置）
    6. 计划实现配置版本管理

## 正在开发：服务注册中心

距离完整可用，剩余开发内容：
1. 服务注册中心-核心模块，维护各业务服务的实例列表，通过发送心跳包的方式，如果能正常执行并得到返回，则认为该实例仍在正常运转，否则，视为该实例失效，删除
2. 服务注册中心-核心模块，高可用或重启可用(?)

为什么要使用服务注册中心？  
微服务架构易于水平扩容，就本项目来说，假设一个场景：用户服务压力过大，想要再部署一个用户服务实例，然后两个实例均摊流量  
现在的结构实现不了这一点：因为从一个服务访问另一个服务的链接，是配置中固定的（结合nginx或许能实现，但这不符合微服务架构的思想）  
现在的结构，与其说是微服务架构，不如说是一整个服务拆成了几个进程，灵活性很差
所以想要引入服务注册中心：

1. 各服务启动时，向注册中心注册自己
2. 各服务想要调用其他服务时，可以通过注册中心获取对应服务的实例列表，然后发起调用

这样就可以带来更好的灵活性，让**微服务架构**名副其实

命名：

1. 服务注册中心-核心模块：registration center core
2. 服务注册中心-嵌入模块：registration center embedded

设计：（第一版，极简模式）

1. 服务注册中心-核心模块自行启动，向配置中心注册核心模块地址
2. 业务服务A，实例1（以下简称A1）启动，自行获取空闲端口号，并拼出监听源，向服务注册中心注册：
    1. 服务注册中心为A服务添加可用实例地址
       核心模块维护的地址，都是公网地址，嵌入模块在维护地址时，判断如果目标地址与自身的ip相同，则使用本地访问`127.0.0.1`  
       包括在连接配置中心和服务注册中心时，嵌入模块也这样做
    2. 注册时，是否在同一个请求内，获取一次目标服务实例地址？
3. 业务服务B尝试调用业务服务A：
    1. （若服务B的嵌入模块已有服务A的实例地址，则跳过该步骤）向服务注册中心申请获取服务A实例地址，得到一组实例地址（拟不超过10个）
    2. 选择一个地址，发起调用

tips:

业务服务启动流程：

1. 从配置中心获取启动配置和服务注册中心-核心模块地址
    1. 因为每一项的配置都读取自数据库，而核心模块地址是动态的，所以不将核心模块的地址放到嵌入模块配置项中
2. 获取一个本机空闲端口，拼上ip，向核心模块注册自己（实例）
3. 注册的同时，就开始监听端口；如果注册失败，就过一会儿再注册（第一版本不实现）

修改：

1. 配置中心实现两个服务：业务服务（主要获取启动配置）和注册中心服务（主要设置注册中心地址）

实现：

1. 编写可以调用全部业务服务的客户端，以下称为**服务注册中心-嵌入模块**，简称为**嵌入模块**，包含以下功能：
    1. 获取本机空闲（可用）端口号：用于启动服务
    2. 获取本机ip地址：用于向服务注册中心注册实例
    3. 向服务注册中心申请获取业务服务的实例地址
    4. 维护业务服务的实例地址列表
        1. 第一版中，实例地址连接出错，且错误原因为rpc连接错误（即proto带给go的err，值不为空），则直接删除
2. 将服务注册中心客户端嵌入各业务服务与网关，然后在调用另一个业务服务时，通过该客户端调用
3. 编写服务注册中心核心模块，包含功能：
    1. 响应业务服务的注册
    2. 响应获取业务服务实例地址。有服务来获取服务A地址时，返回一组服务A实例的地址，拟不超过10个，允许一次获取多个服务的实例地址列表
    3. （后续版本实现，第一版仅实现接口，不实现功能）维护业务服务实例地址列表，拟通过发送心跳包的方式

更新：

1. 嵌入模块，选择实例链接的方式，考虑升级为**根据响应时间计算权重**
2. 嵌入模块，维护持有的业务服务实例地址列表的方式，考虑升级为**出现网络错误时，将该地址降级，如果所有地址都降级了，则重新向核心模块请求**
3. 嵌入模块，拟集成**切换地址**、**重试**功能
4. 核心模块，维护业务服务实例地址列表，拟通过发送心跳包的方式，如果目标服务未响应，保留其地址，但不发送给嵌入模块
5. 嵌入模块，获取到的目标服务地址，如果与当前服务处于同一局域网内，则使用内网ip访问（没想好怎么判断内网）
6. 嵌入模块，在向核心模块注册业务服务实例地址时，如果核心模块还未启动，如何处理？——第一版本将直接退出

思考：

1. 嵌入模块维护的实例地址列表，与核心模块维护的列表，同步策略，是否可以主动同步？
2. 几乎所有服务的启动，都依赖配置中心，是否考虑添加启动方式：配置中心连不上，就使用配置文件？

## 性能监控(draft)

pprof

## 调用链追踪(draft)

日志收集，一个请求在各环节拥有同一个请求ID

## 熔断、限流、降级(draft)

熔断、降级拟合并到服务注册中心，限流拟合并到API网关

## API 网关

> 只处理http post请求，忽略其他类型的请求（忽略：直接返回成功）

网关层的主要作用是隐藏业务服务，由网关层接收全部外部访问，然后分发给各业务服务，以实现**业务服务不对外暴露**的目的

网关层还可以引入一些公共处理，例如限流、降级等功能，以及一些公共处理，例如下面提到的多登问题

### http请求响应过程

> 加载插件

1. 判断请求方法，忽略全部非`http post`方法的请求
2. 判断**请求来源**，若请求来源**无效**（未注册），则拒绝该请求
    1. 请求来源：http请求头`Unnamed-Plan-Source`字段的值
    2. 无效：启动时注册有效的来源列表，不存在于列表中的请求来源视为无效
3. 插件钩子函数：`before invoke`
4. 执行对应请求的处理函数
    1. 所有处理函数在程序启动时注册，此处根据URI获取
5. 插件钩子函数：`after invoke`
    1. 处理函数执行出错时，不执行`after invoke`函数

### http res

```go 
type ResponseData struct {
	HasError bool   `json:"hasError"`
	Data     string `json:"data"`
}
```

```hasError```表示http请求是否正确执行并按照预期返回：

1. 请求正常执行：```data```是```json string```
2. 请求执行失败：```data```是```string```类型的错误信息

### 多处登录限制 multi-login limit

#### 目的

限制同一用户同时登录多个终端的情况

#### 策略

1. 同一用户，在同一个**限制登录**的来源上，**最多**只能登录一次
2. 当一名用户尝试在同一个来源的**不同终端**上登录时，先登录的终端将被收回登录权限
    1. 不同终端：例如两个浏览器标签页

#### 设计

> 本节默认请求来源有效

1. 前端登录，获得`token`，保存到`session storage`
2. 前端其他请求将携带`token`，后端校验，校验通过则继续执行请求，满足以下条件的，视为验证通过：
    1. 后端能够从请求中解析出符合格式的`user id`与`token`
    2. `user id`与`token`是匹配的
    3. 该用户在该来源的**上一次请求时间**距**此刻**不超过一定值（可配置）
3. 前端的每一个登录请求都会生成新的`token`，后端仅记录最后一个
    1. 如此，新的登录请求成功时，旧的登录失效（旧`token`验证不通过）

#### 问题

1. 考虑引入缓存层保存用户登录信息
2. 后端识别**请求头**中的关键参数，然后把关键参数写在**请求体**里返回，  
   这种做法能够最大程度兼容```go http server```和```vue axios interceptor```的原生写法  
   简单来说就是容易实现，后续考虑统一
    1. 考虑使用服务端设置cookie的方式，涉及跨域问题

### 使用ip可能带来的共用session storage问题

> 强调：使用不同的域名（源）不会存在该问题

没有买域名，对于前台界面和后台界面的路径，参考nginx配置：（ip仅供示意）

1. public：https://117.50.177.201
2. admin ：https://117.50.177.201/admin

这就导致两个网站会共用session storage，因为我将登录信息保存在vuex、使用session storage做的vuex防刷新，  
以至于当我登录了前台界面之后，在当前浏览器标签页，通过修改url的方式访问后台界面，后台界面能够读到前台界面的vuex

又因为我没有为两个网站做代码区分，即vuex的`key`都叫`vuex`、**是否登录**字段都叫`isLogin`，所以仅从界面来看，我做到了特殊情况下的单点登录...

对此，我的解决办法是，不同的网站，vuex写session storage时，使用不同的key，以避免与其他网站的session storage混用

效果：（访问其他网站，默认在同一个浏览器标签页内）

1. 访问前台界面，登录，访问后台界面：未登录
2. 访问前台界面，登录，访问后台界面，访问前台界面：登录
3. 访问前台界面，登录，访问后台界面，登录，访问前台界面：登录

## 服务测试

### 为什么想要写服务测试

现在想测试一个功能，需要启动服务，然后通过grpcui或postman等工具，构造请求参数、发起调用……  
这太麻烦了，例如我调试一个**修改文件**功能，调试时间比思考和写代码的时间都长  
所以我想要一个快速测试，最好不用启动服务，也不用构造参数

### 设计

构造需要测试的服务实例，使用真实数据库，mock其他服务

1. 准备阶段：
    1. 创建测试用数据库表
        1. 测试表表名由**正式表名+时间戳**构成，与正式表区分开
    2. 预设测试数据，包含数据库记录与请求参数
    3. 构造服务实例
    4. mock其他服务
2. 测试服务功能（以下步骤对应一个功能）：
    1. 构造请求参数
        1. 一些非常规的请求参数，例如上传文件时的文件原文，通过真实请求获得，即真实上传一个文件，然后拿到它的内容
    2. 调用请求方法
    3. 检查执行结果
        1. 读请求只需要验证请求方法返回值
        2. 写请求需要验证数据库记录，可能需要新的数据库查询语句，拟单独写在测试代码里
3. 测试结束后：
    1. 若测试全部通过，则删除测试用数据库表

### 问题

1. 测试的配置怎么办，在实装配置中心后，其他服务通过配置中心获取配置，配置的改变很难实时反馈到测试配置上
