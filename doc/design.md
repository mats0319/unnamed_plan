# 设计草稿

## 编写proto生成ts调用代码工具

原因：google的官方工具不支持根据proto文件生成ts调用代码，民间虽已有相关实现，但如果以学习为目的，我自然也可以实现一遍。

简述：使用go语言，仅支持google推荐的protocol buffer编写格式、仅支持我用到的部分功能 ^_^

说明：

1. 因为是自用工具，所以灵活性比较高，可以让两边双向奔赴，恩，简单来说，就是工具某个逻辑不好写了，可以规定proto文件换一种写法...
2. 最初计划一步到位：就是直接生成完整的ts代码，但是发现问题很多，所以先实现结构体部分，也就是message

功能：

1. 计算生成顺序：有的proto文件会依赖其他文件，所以要先整理所有文件的生成顺序（通过import关键词，构建生成依赖关系，拟参考前端任务模块的构造方式，bfs）
2. 定义预期结构：即将proto文件解析成go结构之后，应该对应到怎样的ts结构，包括message和service
3. 简单的message、嵌套的message如何解析
4. message的字段怎么解析，复杂一些的例如：带repeated修饰符的字段、引用了其他proto文件中的结构的字段等
5. service怎么解析，请求的url怎么提供

实现：

1. 目标：解析形如`message/enum XXX { }`的结构，对于message，考虑嵌套message的可能（匹配大括号）
2. 具体的解析，要看读到的内容是什么样子的，需要考虑注释
3. 对于enum，硬解析即可
4. 对于message的每一个键值对，忽略等号右侧内容，左侧部分去掉前导、后导空格，按照中间的空格分开；  
   最后一项是变量名，上一项是类型，如果前面还有，就是修饰符  
   如果变量类型的定义不在当前文件，则要去其他文件中找，同时，根据两个文件是否在同一个包(package)内，  
   变量类型要求不带（一个包）/带（非一个包）包名，不过不用特殊处理，我们把生成的文件放在一起，它自己就会找到的

## 调用链追踪

学习微服务-调用链追踪——收集日志，统一分析；每一条日志都需要记录请求ID、服务ID、当前实例ID、来源实例ID，
然后不同文件中根据请求ID和来源实例ID还原调用链路。这样一来，对于当前项目，需要改造的地方有：

1. 网关层，收到请求、即将返回请求处理结果时
2. 业务服务，接收到网关转发的请求时打印日志，然后不出错就不打印了，出错的打印也要添加请求ID
3. 网关层向业务服务转发请求时，要带上请求ID
4. 业务服务启动的时候，要为自己生成一个实例ID，服务ID可以就用定义好的常量，在分析的时候，也能知道这一步是哪个服务做的
5. 日志格式序列化和反序列化
6. 日志收集，rc模块增加方法：读取日志文件并解析，返回请求日志数组
    1. 因为我们只想要网络请求相关日志，而不想要系统启动日志（例如连接到数据库成功），所以在rc模块解析文件
    2. 日志文件过大如何处理——拟为接口添加分页功能，即读取日志文件的多少行到多少行，然后读文件的时候按行读
7. 日志分析，编写新的服务分析日志
    1. 日志分析服务会保存从各业务服务实例获取的日志，同时记录每个实例的日志获取到多少行
    2. 分析过程就是获取相同请求ID的日志记录的过程，获取到之后按照请求来源实例ID串下去，就是调用链，给admin展示的就是调用链

实现步骤：

1. 日志收集
    1. admin为S级管理员新增页面：查看日志
    2. 编写新的日志收集功能，编写新的服务（以下称为**调用链追踪**服务），与核心服务平级
    3. 前端向网关发起请求，网关转发请求到调用链追踪服务
2. 编写日志分析功能
    1. 日志格式序列化和反序列化
    2. 日志提取和分析
3. 展示日志分析结果

待处理：

1. 需要考虑展示给admin的内容

## 循环依赖问题

总结：微服务的循环依赖问题，指的是微服务的几个业务服务之间出现的循环依赖，一些基础设施，例如数据库、消息队列以及本项目的rce模块，
不属于业务服务，所以即使某个业务与基础设施相互依赖，也不认为它们之间构成微服务的循环依赖。

服务间传递消息：

1. 每个需要调用其他服务的服务，内置一个服务注册中心-嵌入模块（rce），由该模块发起调用
2. 服务启动时，rce模块向rcc（服务注册中心-核心模块）注册自己
3. 调用另一个服务时，如果没有对应服务的target，则向rcc申请获取

当前实现：

1. 我们按照模块划分服务，所以可能同时存在服务A调用服务B、服务B又要调用服务A的情况，这将构成循环依赖
    1. 虽然现在没有循环依赖的例子，不过这是可能存在的，假设哪天我要做一个新功能：  
       **一个用户登录`public_web`时，如果他没有上传过文件，则对其屏蔽云文件模块**  
       假设我们通过向云文件服务查询来确定该用户是否上传过文件，这时用户服务将依赖云文件服务；之前有云文件服务依赖于用户服务，形成循环依赖
    2. 使用消息队列，原本的**循环依赖**将变成**所有服务都依赖于消息队列**，以此实现解耦

循环依赖的坏处：

1. 循环依赖是一个不好的现象，简单来说，它会将微服务架构变成**分布式单体架构**，  
   想象一下，两个服务构成循环依赖，修改其中一个，另一个也要测试，维护起来很麻烦；  
   再想象一下，构成循环依赖的服务在部署的时候要一起部署，只部署一个，项目没法跑起来

如何避免服务之间出现循环依赖：

1. 明确定义服务之间的层级关系，**高级服务**可以依赖**基础服务**，反之，不行
    1. 例如问题1中的例子，将用户服务定义为基础服务，我们可以在用户表中增加字段，记录该用户是否上传过文件，
       由云文件服务触发该字段的更新，此时用户服务就不用依赖云文件服务了
2. 重新划分服务/定义服务边界，将2个服务的依赖环展开成3个服务的依赖链（或者将其合并）
    1. 举个例子，假设服务A、B构成循环依赖，我们将服务B拆分成B1、B2，  
       其中B1包含依赖服务A的部分，而原本服务A依赖的服务B的部分则转移到服务B2，  
       即此时的依赖关系，由`A->B,B->A`转换成`B1->A->B2`，循环被打破了
3. 异步调用
    1. 举个例子，当我们使用消息队列的时候，服务间的循环依赖就变成了所有服务都依赖于消息队列

我个人更倾向于前两种方式：使用更好的设计来解决问题

思考：

1. 引入消息队列是为了解决循环依赖，可服务向消息队列写消息是**服务依赖于消息队列**，  
   而消息队列向服务推送消息是**消息队列依赖于服务**，那么这是不是一种新的循环依赖呢？
   不是，我们要避免的，是微服务架构内的**业务服务**之间出现循环依赖，而消息队列更像是基础设施  
   因为业务服务与基础设施相互依赖，并没有前面提到的循环依赖的坏处；
   换一个例子，mysql支持订阅数据库的变化，那么是不是mysql和业务服务之间也是循环依赖呢？显然不是

## 性能监控

pprof

## 熔断、限流、降级

熔断、降级拟合并到服务注册中心，限流拟合并到API网关
