# 设计草稿

## ui的减法设计

现在一共有3个前端项目，维护起来过于繁琐，考虑做减法：
1. 将public_web/admin_web合并成一个项目
2. 将public_mobile合并进上一步中的项目
3. 使用vue3
4. 这样一来，就是一个vue3的多页应用，然后一共有2个page，分别表示web端和mobile端，没有了admin_mobile的unsupported页面

新的web端：使用基础的public_web，然后在查看云文件页面，将上传做成drawer

新建一个vue3项目，然后一点一点复制代码过去

## 调用链追踪

学习微服务-调用链追踪——收集日志，统一分析；每一条日志都需要记录请求ID、服务ID、当前实例ID、来源实例ID，
然后不同文件中根据请求ID和来源实例ID还原调用链路。这样一来，对于当前项目，需要改造的地方有：

1. 网关层，收到请求、即将返回请求处理结果时
2. 业务服务，接收到网关转发的请求时打印日志，然后不出错就不打印了，出错的打印也要添加请求ID
3. 网关层向业务服务转发请求时，要带上请求ID
4. 业务服务启动的时候，要为自己生成一个实例ID，服务ID可以就用定义好的常量，在分析的时候，也能知道这一步是哪个服务做的
5. 日志格式序列化和反序列化
6. 日志收集，rc模块增加方法：读取日志文件并解析，返回请求日志数组
    1. 因为我们只想要网络请求相关日志，而不想要系统启动日志（例如连接到数据库成功），所以在rc模块解析文件
    2. 日志文件过大如何处理——拟为接口添加分页功能，即读取日志文件的多少行到多少行，然后读文件的时候按行读
7. 日志分析，编写新的服务分析日志
    1. 日志分析服务会保存从各业务服务实例获取的日志，同时记录每个实例的日志获取到多少行
    2. 分析过程就是获取相同请求ID的日志记录的过程，获取到之后按照请求来源实例ID串下去，就是调用链，给admin展示的就是调用链

实现步骤：

1. 日志收集
    1. admin为S级管理员新增页面：查看日志
    2. 编写新的日志收集功能，编写新的服务（以下称为**调用链追踪**服务），与核心服务平级
    3. 前端向网关发起请求，网关转发请求到调用链追踪服务
2. 编写日志分析功能
    1. 日志格式序列化和反序列化
    2. 日志提取和分析
3. 展示日志分析结果

待处理：

1. 需要考虑展示给admin的内容

## 循环依赖问题

总结：微服务的循环依赖问题，指的是微服务的几个业务服务之间出现的循环依赖，一些基础设施，例如数据库、消息队列以及本项目的rce模块，
不属于业务服务，所以即使某个业务与基础设施相互依赖，也不认为它们之间构成微服务的循环依赖。

服务间传递消息：

1. 每个需要调用其他服务的服务，内置一个服务注册中心-嵌入模块（rce），由该模块发起调用
2. 服务启动时，rce模块向rcc（服务注册中心-核心模块）注册自己
3. 调用另一个服务时，如果没有对应服务的target，则向rcc申请获取

当前实现：

1. 我们按照模块划分服务，所以可能同时存在服务A调用服务B、服务B又要调用服务A的情况，这将构成循环依赖
    1. 虽然现在没有循环依赖的例子，不过这是可能存在的，假设哪天我要做一个新功能：  
       **一个用户登录`public_web`时，如果他没有上传过文件，则对其屏蔽云文件模块**  
       假设我们通过向云文件服务查询来确定该用户是否上传过文件，这时用户服务将依赖云文件服务；之前有云文件服务依赖于用户服务，形成循环依赖
    2. 使用消息队列，原本的**循环依赖**将变成**所有服务都依赖于消息队列**，以此实现解耦

循环依赖的坏处：

1. 循环依赖是一个不好的现象，简单来说，它会将微服务架构变成**分布式单体架构**，  
   想象一下，两个服务构成循环依赖，修改其中一个，另一个也要测试，维护起来很麻烦；  
   再想象一下，构成循环依赖的服务在部署的时候要一起部署，只部署一个，项目没法跑起来

如何避免服务之间出现循环依赖：

1. 明确定义服务之间的层级关系，**高级服务**可以依赖**基础服务**，反之，不行
    1. 例如问题1中的例子，将用户服务定义为基础服务，我们可以在用户表中增加字段，记录该用户是否上传过文件，
       由云文件服务触发该字段的更新，此时用户服务就不用依赖云文件服务了
2. 重新划分服务/定义服务边界，将2个服务的依赖环展开成3个服务的依赖链（或者将其合并）
    1. 举个例子，假设服务A、B构成循环依赖，我们将服务B拆分成B1、B2，  
       其中B1包含依赖服务A的部分，而原本服务A依赖的服务B的部分则转移到服务B2，  
       即此时的依赖关系，由`A->B,B->A`转换成`B1->A->B2`，循环被打破了
3. 异步调用
    1. 举个例子，当我们使用消息队列的时候，服务间的循环依赖就变成了所有服务都依赖于消息队列

我个人更倾向于前两种方式：使用更好的设计来解决问题

思考：

1. 引入消息队列是为了解决循环依赖，可服务向消息队列写消息是**服务依赖于消息队列**，  
   而消息队列向服务推送消息是**消息队列依赖于服务**，那么这是不是一种新的循环依赖呢？
   不是，我们要避免的，是微服务架构内的**业务服务**之间出现循环依赖，而消息队列更像是基础设施  
   因为业务服务与基础设施相互依赖，并没有前面提到的循环依赖的坏处；
   换一个例子，mysql支持订阅数据库的变化，那么是不是mysql和业务服务之间也是循环依赖呢？显然不是

## 性能监控

pprof

## 熔断、限流、降级

熔断、降级拟合并到服务注册中心，限流拟合并到API网关
