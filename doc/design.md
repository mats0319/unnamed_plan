# 设计

## API 网关

只接受http请求

### http请求响应过程

1. 判断**请求来源**，若请求来源无效（未注册），则拒绝该请求
    1. 请求来源：http请求头```Unnamed-Plan-Source```字段的值
    2. 启动时注册有效的来源列表
2. 获取对应请求的处理函数
    1. 所有处理函数在程序启动时注册，此处根据URI获取
3. 多处登录限制：验证（多处登录限制详见下文）
    1. 满足下列条件之一的，跳过验证：
        1. 未开启多登限制
        2. 请求来自**非限制来源**
        3. 针对该处理函数**不启用**多登限制（注册处理函数时设置）
    2. 执行验证并通过后，刷新用户在该来源的**上一次请求时间**
        1. 验证不通过的请求将被拒绝
4. 调用处理函数
5. 多处登录限制：刷新登录信息
    1. 满足下列条件之一的，不刷新登录信息：
        1. 未开启多登限制
        2. 请求来自**非限制来源**
        3. 该处理函数**未启用**刷新token功能（注册处理函数时设置）
        4. 处理函数执行失败
    2. 刷新登录信息会同时刷新```token```和**上一次请求时间**

### http res

```go 
type ResponseData struct {
	HasError bool   `json:"hasError"`
	Data     string `json:"data"`
}
```

```hasError```表示http请求是否正确执行并按照预期返回：

1. 请求正常执行：```data```是```json string```
2. 请求执行失败：```data```是```string```类型的错误信息

### 多处登录限制 multi-login limit

#### 目的

限制同一用户同时登录多个终端的情况

#### 策略

1. 同一用户，在同一个**限制登录**的来源上，**最多**只能登录一次
2. 当一名用户尝试在同一个来源的**不同终端**上登录时，先登录的终端将被收回登录权限
    1. 不同终端：例如两个浏览器标签页

#### 实现

1. 前端将```token```保存到```sessionStorage```
2. 前端通过自定义的http请求头携带身份验证参数
    1. 来源：```Unnamed-Plan-Source```
    2. 用户ID：```Unnamed-Plan-User```
    3. token：```Unnamed-Plan-Token```
3. 满足以下全部条件的，视为验证通过：
    1. 解析出有效的```user id```与```token```
    2. 程序内保存有该```user id```的登录信息
    3. 该用户在该来源的**上一次请求时间**距**此刻**不超过一定值（可配置）

#### 问题

1. 考虑引入缓存层保存用户登录信息
2. 后端识别**请求头**中的关键参数，然后把关键参数写在**请求体**里返回，  
   这种做法能够最大程度兼容```go http server```和```vue axios interceptor```的原生写法  
   简单来说就是容易实现，后续考虑统一
    1. 考虑使用服务端设置cookie的方式，涉及跨域问题

## 配置中心(draft)

配置中心界面直接访问配置中心服务，不经过公共API网关

配置中心服务内置一个单独的、小型的API网关，包含转发请求与多登限制等功能

登录：配置中心内置一张用户表，内置管理员用户，仅支持查询

侧边栏与内容区：

- 当前配置：展示当前支持的全部服务及其应用中的配置详情
- 版本（每一个版本都包含支持的全部服务的配置详情）
    - 生成新版本
        - 版本号：```v1.2.3-alpha```格式，4个输入框
        - 版本概述
        - 列举当前支持的服务及其挂载的配置：成点击加载 - 给一个按钮，点击才查询、计算，此处配置使用完整的json str
        - 生成按钮
    - 查询：表格展示服务配置的所有版本，表格有一列**操作**，包含修改描述、应用操作
- 服务（无版本概念，仅保留当前支持的服务）
    - 新增
        - 服务名
        - 服务ID：允许**随机生成**或**根据服务名生成**uid，寻找前端uid库，比较前后端生成结果
        - 挂载配置：点击加载 - 给一个按钮，点击查询当前所有可挂载的配置名，此处使用配置名
        - 是否隐藏：允许创建隐藏服务
        - 创建按钮
    - 查询：表格展示支持的所有服务，表格有一列**操作**，包含修改、删除操作
- 配置（无版本概念，仅保留当前允许挂载的配置）
    - 新增
        - 配置名
        - 配置ID：同服务ID
        - 编辑配置详情：第一版本做成直接编辑json str
        - 是否隐藏：允许创建隐藏配置
        - 创建按钮
    - 查询：表格展示允许挂载的配置，表格有一列**操作**，包含修改、删除操作

tips：

1. 因为不同的服务可能包含同一个配置，所以配置版本表示的是**配置中心支持的全部服务的配置详情**的版本
2. 服务和配置都有**隐藏**和**删除**方法
    1. 共同点：都不能使用，隐藏或删除的服务不会在新版本中支持；隐藏或删除的配置不允许挂载到服务上
    2. 不同点：隐藏不会删除数据库记录、前端可见，如果只是想临时不使用某个服务或配置，隐藏可以让你不必删除后再重新创建

### 问题

1. 后端拟于内存中做缓存：当前版本配置、当前支持的服务、当前可挂载的配置；在修改数据库后更新
    1. 思考配置中心多节点对应的缓存同步问题，后面再做
2. 拟通过只有一个账号、限制每个账号只能登录一个终端的方式，避免多人同时操作配置，然后前端缓存查询结果
    1. 不太好缓存，暂时记下来，后面再做，第一个版本所有的内容都走查询、不缓存

## 服务注册中心(draft)

目的：解决业务服务实例数量提升所带来的新问题，例如负载均衡、实例状态维护等

1. 服务注册中心实现所有业务服务的客户端代码与转发代码
    1. 调用链调整为：API网关/其他服务 -> 服务注册中心 -> 目标服务
    2. 服务注册中心应实现全部rpc方法的服务端与客户端，即，服务注册中心在收到请求时，仅做转发
    3. 是否要支持**查询服务注册中心当前支持的业务函数**呢？
    4. note：跨服务调用通过服务注册中心，是因为这样调用方就不需要知道目标服务地址了，负载均衡、目标服务状态等都不需要关心

## 性能监控(draft)

pprof

## 调用链追踪(draft)

日志收集，一个请求在各环节拥有同一个请求ID

执行业务的服务中增加日志

rpc方法拟使用自定义错误类型

## 熔断、限流、降级(draft)

熔断、降级拟合并到服务注册中心，限流拟合并到API网关
