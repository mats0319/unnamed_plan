# 设计

> 随着文档越写越多，新的功能设计往往需要往下翻若干行才能找到，故重新分类本文档：
> 1. 正在开发的功能（指导代码编写）
> 2. 已实现的功能（归档）
> 3. 草稿（关于开发笔记中**计划开发内容**模块的思考，使用`draft`标识）

## 正在开发——配置中心

场景：随着测试的引入，假设现在我要改一个数据库的地址，我需要改四个服务x每个服务三个配置文件一共十二处，所以能不能统一管理配置？

设计：

如何建立配置中心与各服务之间的联系呢？

1. 这个问题可以通过统一的公共配置文件解决，配置文件里写配置中心地址、服务注册中心地址等所有服务都会用到的地址，  
   然后每个服务里挂载一个**业务服务客户端**，这个客户端就负责去同步配置、注册服务之类的业务无关的事情，  
   这个客户端通过`../config.json`或类似的路径找到上面提到的**公共配置文件**，然后配置中心地址有变化了，只需要改这个文件

这样一来，问题就回到了如何设计配置中心的功能和结构

先列一下想要的功能吧：

1. （服务）读取配置
2. 修改配置
3. 更新配置
4. 配置环境管理：开发、生产环境——测试怎么办？
    1. 获取配置时，支持传入指定配置文件路径，代替前往配置中心获取配置，这样可以在测试时不用启动配置中心，  
       至于指定的配置文件，可以通过配置中心管理，即测试配置也加入配置中心管理范围，  
       这要求配置中心可以写文件，把不同服务的测试配置写成单独的文件
5. 配置版本管理：用户服务的历史版本

至于实现，还是想做模块化的配置，即拆分一个服务的全部配置为一组配置项，而每一个配置项又包含一组配置子项

1. 配置项：例如用户服务包含服务基础配置（启动端口等）与数据库配置，这里的服务基础配置与数据库配置就称作配置项
2. 配置子项：例如数据库配置包含数据库管理系统(DBMS)名称、数据库地址等，这里的DBMS、数据库地址就称作配置子项

数据库表设计：

服务配置表：

1. service id：与level结合，唯一
    1. 建表时，编写联合唯一约束
2. service name
3. level：配置等级，包括`dev`/`production`/`test`/`default`等，其中默认等级用于未找到指定等级配置时的下位替代，优先级低
4. config item ids：配置项ID列表，此处仅保存配置项ID，而非详细的、包含配置子项的完全版本
5. is support：是否支持，若一个服务没有**支持的默认等级的配置**，则认为配置中心不支持该服务

配置项表：（如果不同的服务或不同的场景，需要同名配置项，例如用户服务和云文件服务都需要数据库配置，则应为不同的服务挂载不同的配置项，例如数据库-用户、数据库-云文件）

1. config item id：根据name生成，不可修改，同名配置项，ID相同（例如，**用户服务数据库**和**云文件服务数据库**的**数据库配置项ID**相同）
2. config item name：标识该配置项名称，如**数据库**，可添加其他备注信息，如**用户服务**、**开发**等
4. config sub-item list：完整的配置子项列表
5. used in：正用在哪些服务配置中，记录服务配置的数据库ID

实现：

配置中心通过数据库维护常规配置，包括测试配置，额外提供测试配置写文件功能

配置中心启动时，加载所有数据库记录，计算出支持的服务（服务有默认配置，且每个配置项均存在）

服务获取配置时，提供服务ID与配置环境（开发、生产等），若该服务无指定环境的配置支持，则尝试获取默认配置，若不存在默认配置，则获取配置失败

1. 举个例子，获取用户服务的开发配置，不存在开发配置时，转而获取默认配置，不存在默认配置时，获取配置失败

数据库保存的服务配置，读取到内存中，采用公共配置格式

内存：

1. 支持的服务配置：map，`map[string]*ConfigWrapper`，服务ID-配置详情（包装结构，字段为各配置等级）
    1. 如果服务配置有变化，直接重新生成对应配置详情
    2. 计算规则：遍历服务配置表数据，如果一个服务配置需要的配置项ID均存在，则视作支持该服务配置，添加到map
2. 服务配置表数据：数组，`[]*ServiceConfig`，保存数据库数据
3. 配置项表数据：数组，`[]*ConfigItem`，保存数据库数据
   1. 服务基础配置的配置项ID与服务ID相同

结构：

配置中心提供编辑界面，使用单独url，直接访问配置中心后端，  
配置中心实现http服务端，支持界面请求；实现rpc服务端，支持其他服务的请求

步骤：

1. 编写配置中心服务，实现配置中心初始化功能，数据修改直接操作数据库
2. 编写其他服务读配置功能，服务从配置中心获取配置失败时，隔一段时间重试几次（拟隔10s，试3次），完全失败了，直接退出
3. 编写配置中心界面

问题：

1. 内存map在提供写方法时，存在数据竞争（并发问题）

## API 网关

> 只处理http post请求，忽略其他类型的请求
> 忽略：直接返回成功

网关层的主要作用是隐藏业务服务，由网关层接收全部外部访问，然后分发给各业务服务，以实现**业务服务不对外暴露**的目的

网关层还可以引入一些公共处理，例如限流、降级等功能，以及一些公共处理，例如下面提到的多登问题

### http请求响应过程

> 加载插件

1. 判断请求方法，忽略全部非`http post`方法的请求
2. 判断**请求来源**，若请求来源**无效**（未注册），则拒绝该请求
    1. 请求来源：http请求头`Unnamed-Plan-Source`字段的值
    2. 无效：启动时注册有效的来源列表，不存在于列表中的请求来源视为无效
3. 插件钩子函数：`before invoke`
4. 执行对应请求的处理函数
    1. 所有处理函数在程序启动时注册，此处根据URI获取
5. 插件钩子函数：`after invoke`
    1. 处理函数执行出错时，不执行`after invoke`函数

### http res

```go 
type ResponseData struct {
	HasError bool   `json:"hasError"`
	Data     string `json:"data"`
}
```

```hasError```表示http请求是否正确执行并按照预期返回：

1. 请求正常执行：```data```是```json string```
2. 请求执行失败：```data```是```string```类型的错误信息

### 多处登录限制 multi-login limit

#### 目的

限制同一用户同时登录多个终端的情况

#### 策略

1. 同一用户，在同一个**限制登录**的来源上，**最多**只能登录一次
2. 当一名用户尝试在同一个来源的**不同终端**上登录时，先登录的终端将被收回登录权限
    1. 不同终端：例如两个浏览器标签页

#### 实现

1. 前端将```token```保存到```sessionStorage```
2. 前端通过自定义的http请求头携带身份验证参数
    1. 来源：```Unnamed-Plan-Source```
    2. 用户ID：```Unnamed-Plan-User```
    3. token：```Unnamed-Plan-Token```
3. 满足以下全部条件的，视为验证通过：
    1. 解析出有效的```user id```与```token```
    2. 程序内保存有该```user id```的登录信息
    3. 该用户在该来源的**上一次请求时间**距**此刻**不超过一定值（可配置）

#### 问题

1. 考虑引入缓存层保存用户登录信息
2. 后端识别**请求头**中的关键参数，然后把关键参数写在**请求体**里返回，  
   这种做法能够最大程度兼容```go http server```和```vue axios interceptor```的原生写法  
   简单来说就是容易实现，后续考虑统一
    1. 考虑使用服务端设置cookie的方式，涉及跨域问题

### 使用ip可能带来的共用session storage问题

> 强调：使用不同的域名（源）不会存在该问题

没有买域名，对于前台界面和后台界面的路径，参考nginx配置：（ip仅供示意）

1. 前台界面：https://117.50.177.201
2. 后台界面：https://117.50.177.201/admin

这就导致两个网站会共用session storage，因为我将登录信息保存在vuex、使用session storage做的vuex防刷新，  
以至于当我登录了前台界面之后，在当前浏览器标签页，通过修改url的方式访问后台界面，后台界面能够读到前台界面的vuex

又因为我没有为两个网站做代码区分，即**是否登录**字段都叫`isLogin`，所以仅从界面来看，我做到了特殊情况下的单点登录...

对此，我的解决办法是，不同的网站，vuex写session storage时，使用不同的key，以避免与其他网站的session storage混用

效果：（访问其他网站，默认在同一个浏览器标签页内）

1. 访问前台界面，登录，访问后台界面：未登录
2. 访问前台界面，登录，访问后台界面，访问前台界面：登录
3. 访问前台界面，登录，访问后台界面，登录，访问前台界面：登录

## 服务测试

### 为什么想要写服务测试

因为现在测试一个功能，需要启动服务，然后通过grpcui或postman等工具，或者直接启动前端代码，构造请求参数、发起调用……  
这太麻烦了，例如我调试一个**修改文件**功能，调试时间比思考和写代码的时间都长  
所以我想要一个快速测试，最好不用启动服务，也不用构造参数

### 设计与实现

构造需要测试的服务实例，使用真实数据库，mock其他服务

1. 准备阶段：
    1. 创建测试用数据库表
        1. 测试表表名由**正式表名+时间戳**构成，与正式表区分开
    2. 预设测试数据，包含数据库记录与请求参数
    3. 构造服务实例
    4. mock其他服务
2. 测试服务功能（以下步骤对应一个功能）：
    1. 构造请求参数
        1. 一些非常规的请求参数，例如上传文件时的文件原文，通过真实请求获得，即真实上传一个文件，然后拿到它的内容
    2. 调用请求方法
    3. 检查执行结果
        1. 读请求只需要验证请求方法返回值
        2. 写请求需要验证数据库记录，可能需要新的数据库查询语句，拟单独写在测试代码里
3. 测试结束后：
    1. 若测试全部通过，则删除测试用数据库表

## 服务注册中心(draft)

目的：解决业务服务实例数量提升所带来的新问题，例如负载均衡、实例状态维护等

## 性能监控(draft)

pprof

## 调用链追踪(draft)

日志收集，一个请求在各环节拥有同一个请求ID

执行业务的服务中增加日志

rpc方法拟使用自定义错误类型

## 熔断、限流、降级(draft)

熔断、降级拟合并到服务注册中心，限流拟合并到API网关
